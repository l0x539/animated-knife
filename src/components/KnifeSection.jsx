/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { forwardRef, useEffect, useMemo, useRef, useState } from "react";
import { useGLTF, useAnimations, Html } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useControls } from "leva";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import gsap from "gsap";
import {
  CONTROLS,
  END,
  END_TRIGGER,
  KNIFE_PATH,
  START,
  TESTING,
  TRIGGER,
} from "../utils/constants";
import { CustomEase } from "gsap/CustomEase";
import { useMediaQuery } from "react-responsive";

if (typeof document !== "undefined") {
  gsap.registerPlugin(ScrollTrigger);
  gsap.registerPlugin(CustomEase);
}
const KnifeSection = (props) => {
  const knife = useRef();
  const { nodes, materials, animations } = useGLTF(KNIFE_PATH);
  const { actions } = useAnimations(animations, knife);

  const { settings } = useMemo(() => {
    return {
      settings: {
        progress: 0,
      },
      translateY: 1, // TO -.3
    };
  }, []);

  const isMobile = useMediaQuery({ maxWidth: 767 });
  const isTablet = useMediaQuery({ minWidth: 768, maxWidth: 991 });

  const { progress, position, scale } = useControls({
    progress: {
      value: 0,
      max: 1,
      min: 0,
      step: 0.01,
    },
    position: {
      value: {
        x: 0,
        y: 0,
        z: 0,
      },
      step: 0.1,
    },
    scale: isMobile ? 3 : 7.6,
  });

  const [duration, setDuration] = useState(0);
  const [mixerAction1, setMixer1] = useState(null);
  const [mixerAction2, setMixer2] = useState(null);
  // const customEase = useMemo(() => CustomEase.create("custom", "M0,0,C0.4,0.018,0.398,0.3,0.507,0.512,0.6,0.693,0.6,0.984,1,1"), []);

  useEffect(() => {
    gsap.to(settings, {
      scrollTrigger: {
        trigger: TRIGGER,
        endTrigger: END_TRIGGER,
        start: START,
        end: END,
        // refreshPriority: -1,
        markers: TESTING,
        onUpdate: (t) => {
          gsap.to(settings, {
            translateY: t.progress > 0 ? (isTablet || isMobile ? -0.1 : -0.3) : 1,
            ease: "power1.out",
          });
          gsap.to(settings, {
            // ADD gsap animation options here.
            progress: t.progress,
            ease: "power1.out",
            // ease: customEase
          });

          gsap.to('.animated-text', 
          {
            stagger: .3,
            y: t.progress > .2 ? 0 : 100,
            opacity: t.progress > .2 ? 1 : 0,
            ease: "power1.out",
          });
        },
      },
    });

    // tl.current.to({}, {
    //   ease: customEase,
    //   scrollTrigger: {
    //     trigger: TRIGGER,
    //     endTrigger: END_TRIGGER,
    //     start: START,
    //     end: END,
    //     // refreshPriority: -1,
    //     markers: TESTING,
    //     scrub: true,
    //     onUpdate: t => {
    //       tl.current.progress(t.progress)
    //     }
    //   }
    // });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [settings]);

  useEffect(() => {
    setDuration(actions["node2Action"].getClip().duration - 0.100000000000001);
    setMixer1(actions["Empty.001Action"].getMixer());
    setMixer2(actions["node2Action"].getMixer());
  }, [actions]);

  useFrame(() => {
    if (mixerAction1 && mixerAction2 && duration) {
      const d = (CONTROLS ? progress : settings.progress) * duration;
      mixerAction1.setTime(d);
      mixerAction2.setTime(d);
      actions["node2Action"].getEffectiveWeight();
      actions["Empty.001Action"].getEffectiveWeight();
      actions["Empty.001Action"].getMixer().update(0.1);
      actions["node2Action"].play();
      actions["Empty.001Action"].play();

      knife.current.position.setY(settings.translateY);
    }
  });

  return (
    <>
      <Knife
        ref={knife}
        nodes={nodes}
        materials={materials}
        {...{
          ...props,
          ...(CONTROLS
            ? { position: [position.x, position.y, position.z], scale }
            : {}),
        }}
      />
      <Html fullscreen
      className={`flex items-center justify-center ${isTablet ? 'gap-60 text-xl': isMobile ? 'gap-28 text-sm' : 'gap-96 text-lg'}`}>
        <div className={`knife-text__left opacity-0 animated-text text-[#9f8561] uppercase font-fjalla`}>
          Full size function
        </div>
        <div className={`knife-text__right opacity-0 animated-text text-[#161616] uppercase font-fjalla`}>
          In the size of house key
        </div>
      </Html>
    </>
  );
};

const Knife = forwardRef(({ nodes, materials, ...props }, knife) => {
  return (
    <group ref={knife} {...props} visible dispose={null}>
      <group name="Scene">
        <group
          name="Empty001"
          position={[0, 0.051, 0]}
          rotation={[3.117, -0.113, 2.927]}
          scale={0.126}
        >
          <group
            name="Armature"
            position={[-0.043, -0.226, -0.074]}
            rotation={[3.126, 0.118, 3.139]}
            scale={0.101}
          >
            <skinnedMesh
              name="node1"
              geometry={nodes.node1.geometry}
              material={materials.MergedBake_Baked}
              skeleton={nodes.node1.skeleton}
            />
            <primitive object={nodes.Bone} />
            <primitive object={nodes.neutral_bone} />
          </group>
          <mesh
            name="node0"
            castShadow
            receiveShadow
            geometry={nodes.node0.geometry}
            material={materials.MergedBake_Baked}
            position={[-0.004, 0.017, 0]}
            rotation={[Math.PI / 2, -Math.PI / 2, 0]}
            scale={10.712}
          />
          <mesh
            name="node2"
            castShadow
            receiveShadow
            geometry={nodes.node2.geometry}
            material={materials.MergedBake_Baked}
            position={[-0.004, 0.017, 0]}
            rotation={[-1.571, 1.536, -3.142]}
            scale={10.712}
          >
            <mesh
              name="D2_logo"
              castShadow
              receiveShadow
              geometry={nodes.D2_logo.geometry}
              material={materials.MergedBake_Baked}
              position={[-0.008, -0.005, -0.007]}
              rotation={[0.002, 0.019, -3.139]}
              scale={0.003}
            />
            <mesh
              name="node25"
              castShadow
              receiveShadow
              geometry={nodes.node25.geometry}
              material={materials.MergedBake_Baked}
            />
          </mesh>
        </group>
      </group>
    </group>
  );
});

export default KnifeSection;

useGLTF.preload(KNIFE_PATH);
